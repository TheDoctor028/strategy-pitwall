# This file has been generated by graphql-codegen. Do not edit it directly.
type AffectedRowsOutput {
  count: Int!
}

type AggregateEvent {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

type Event {
  duration: Int!
  greenFlagOffset: Int!
  id: String!
  name: String!
  raceStartSim: DateTimeISO!
  series: String
  sessionStart: DateTimeISO!
}

type EventAvgAggregate {
  duration: Float
  greenFlagOffset: Float
}

input EventAvgOrderByAggregateInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
}

type EventCountAggregate {
  _all: Int!
  duration: Int!
  greenFlagOffset: Int!
  id: Int!
  name: Int!
  raceStartSim: Int!
  series: Int!
  sessionStart: Int!
}

input EventCountOrderByAggregateInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
  id: SortOrder
  name: SortOrder
  raceStartSim: SortOrder
  series: SortOrder
  sessionStart: SortOrder
}

input EventCreateInput {
  duration: Int!
  greenFlagOffset: Int!
  id: String
  name: String!
  raceStartSim: DateTimeISO!
  series: String
  sessionStart: DateTimeISO!
}

type EventGroupBy {
  _avg: EventAvgAggregate
  _count: EventCountAggregate
  _max: EventMaxAggregate
  _min: EventMinAggregate
  _sum: EventSumAggregate
  duration: Int!
  greenFlagOffset: Int!
  id: String!
  name: String!
  raceStartSim: DateTimeISO!
  series: String
  sessionStart: DateTimeISO!
}

type EventMaxAggregate {
  duration: Int
  greenFlagOffset: Int
  id: String
  name: String
  raceStartSim: DateTimeISO
  series: String
  sessionStart: DateTimeISO
}

input EventMaxOrderByAggregateInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
  id: SortOrder
  name: SortOrder
  raceStartSim: SortOrder
  series: SortOrder
  sessionStart: SortOrder
}

type EventMinAggregate {
  duration: Int
  greenFlagOffset: Int
  id: String
  name: String
  raceStartSim: DateTimeISO
  series: String
  sessionStart: DateTimeISO
}

input EventMinOrderByAggregateInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
  id: SortOrder
  name: SortOrder
  raceStartSim: SortOrder
  series: SortOrder
  sessionStart: SortOrder
}

input EventOrderByWithAggregationInput {
  _avg: EventAvgOrderByAggregateInput
  _count: EventCountOrderByAggregateInput
  _max: EventMaxOrderByAggregateInput
  _min: EventMinOrderByAggregateInput
  _sum: EventSumOrderByAggregateInput
  duration: SortOrder
  greenFlagOffset: SortOrder
  id: SortOrder
  name: SortOrder
  raceStartSim: SortOrder
  series: SortOrderInput
  sessionStart: SortOrder
}

input EventOrderByWithRelationInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
  id: SortOrder
  name: SortOrder
  raceStartSim: SortOrder
  series: SortOrderInput
  sessionStart: SortOrder
}

enum EventScalarFieldEnum {
  duration
  greenFlagOffset
  id
  name
  raceStartSim
  series
  sessionStart
}

input EventScalarWhereWithAggregatesInput {
  AND: [EventScalarWhereWithAggregatesInput!]
  NOT: [EventScalarWhereWithAggregatesInput!]
  OR: [EventScalarWhereWithAggregatesInput!]
  duration: IntWithAggregatesFilter
  greenFlagOffset: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  raceStartSim: DateTimeWithAggregatesFilter
  series: StringNullableWithAggregatesFilter
  sessionStart: DateTimeWithAggregatesFilter
}

type EventSumAggregate {
  duration: Int
  greenFlagOffset: Int
}

input EventSumOrderByAggregateInput {
  duration: SortOrder
  greenFlagOffset: SortOrder
}

input EventUpdateInput {
  duration: IntFieldUpdateOperationsInput
  greenFlagOffset: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  raceStartSim: DateTimeFieldUpdateOperationsInput
  series: NullableStringFieldUpdateOperationsInput
  sessionStart: DateTimeFieldUpdateOperationsInput
}

input EventUpdateManyMutationInput {
  duration: IntFieldUpdateOperationsInput
  greenFlagOffset: IntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  raceStartSim: DateTimeFieldUpdateOperationsInput
  series: NullableStringFieldUpdateOperationsInput
  sessionStart: DateTimeFieldUpdateOperationsInput
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  duration: IntFilter
  greenFlagOffset: IntFilter
  id: StringFilter
  name: StringFilter
  raceStartSim: DateTimeFilter
  series: StringNullableFilter
  sessionStart: DateTimeFilter
}

input EventWhereUniqueInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  duration: IntFilter
  greenFlagOffset: IntFilter
  id: String
  name: StringFilter
  raceStartSim: DateTimeFilter
  series: StringNullableFilter
  sessionStart: DateTimeFilter
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createOneEvent(data: EventCreateInput!): Event!
  deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
  deleteOneEvent(where: EventWhereUniqueInput!): Event
  updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): AffectedRowsOutput!
  updateOneEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  upsertOneEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Query {
  aggregateEvent(cursor: EventWhereUniqueInput, orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): AggregateEvent!
  event(where: EventWhereUniqueInput!): Event
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  findFirstEvent(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): Event
  findFirstEventOrThrow(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): Event
  getEvent(where: EventWhereUniqueInput!): Event
  groupByEvent(by: [EventScalarFieldEnum!]!, having: EventScalarWhereWithAggregatesInput, orderBy: [EventOrderByWithAggregationInput!], skip: Int, take: Int, where: EventWhereInput): [EventGroupBy!]!
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}